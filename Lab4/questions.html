<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ответы на контрольные вопросы по CSS</title>
</head>
<body>

    <div class="container">
        <h1>Контрольные вопросы по CSS-селекторам</h1>

        <h2>1. Какие типы селекторов CSS существуют, и в чем отличие между селектором класса и идентификатора?</h2>
        <p>
            Существуют следующие основные **типы селекторов** CSS:
        </p>
        <ul>
            <li>**Селекторы типов (элементов):** выбирают элементы по их имени (`p`, `div`, `h1`).</li>
            <li>**Селекторы классов:** выбирают элементы по атрибуту `class` (`.highlight`).</li>
            <li>**Селекторы идентификаторов:** выбирают элементы по атрибуту `id` (`#main-header`).</li>
            <li>**Универсальный селектор:** выбирает все элементы (`*`).</li>
            <li>**Атрибутные селекторы:** выбирают элементы по наличию или значению атрибута (`[type="text"]`).</li>
            <li>**Псевдоклассы и псевдоэлементы:** выбирают элементы на основе состояния или части элемента (`:hover`, `::before`).</li>
            <li>**Комбинаторы:** объединяют другие селекторы (селектор потомков, селектор соседей и др.).</li>
        </ul>
        <p>
            <strong>Отличие между селектором класса и идентификатора:</strong>
        </p>
        <ul>
            <li>
                <strong>Селектор класса (<code>.name</code>):</strong> Предназначен для многократного использования. Один класс может быть применен к **множеству элементов** на странице.
                <br>Пример: `&lt;div class="alert"&gt;` и `.alert { color: red; }`.
            </li>
            <li>
                <strong>Селектор идентификатора (<code>#name</code>):</strong> Предназначен для выбора **уникального элемента** на странице. В соответствии со стандартами HTML, `id` должен быть уникальным для всей страницы. Селекторы идентификаторов обладают более **высоким приоритетом (специфичностью)**, чем селекторы классов.
                <br>Пример: `&lt;div id="sidebar"&gt;` и `#sidebar { width: 300px; }`.
            </li>
        </ul>

        <h2>2. Как работает универсальный селектор (*), и в каких случаях его использование может быть полезно?</h2>
        <p>
            **Универсальный селектор** обозначается звездочкой (<code>*</code>) и выбирает **все элементы** HTML на странице, независимо от их типа, класса или идентификатора.
        </p>
        <p>
            <strong>Пример:</strong> <code>* { box-sizing: border-box; }</code> — применит свойство ко всем элементам.
        </p>
        <p>
            <strong>Полезность:</strong>
        </p>
        <ul>
            <li>**Обнуление стилей (Reset/Normalize):** Часто используется для установки общих базовых свойств, например, сброса полей и отступов: <code>* { margin: 0; padding: 0; }</code>.</li>
            <li>**Общая модель рамки:** Часто используется для установки свойства <code>box-sizing</code>, чтобы рамка и отступы не увеличивали общую ширину элементов: <code>* { box-sizing: border-box; }</code>.</li>
            <li>**Наследование:** Применить специфический шрифт или цвет ко всей странице, если это не работает через `body`.</li>
        </ul>

        <h2>3. Что такое псевдоклассы и псевдоэлементы? Приведите примеры их использования.</h2>
        <p>
            <strong>Псевдоклассы (Pseudo-classes)</strong> обозначаются одним двоеточием (<code>:</code>) и позволяют применять стили к элементам на основе их **состояния** (например, элемент находится под курсором) или их **положения** в структуре документа (например, первый дочерний элемент).
        </p>
        <p>
            <strong>Пример псевдоклассов:</strong>
        </p>
        <ul>
            <li><code>:hover</code>: элемент, на который наведен курсор. <br>Пример: <code>a:hover { color: orange; }</code></li>
            <li><code>:first-child</code>: первый дочерний элемент своего родителя. <br>Пример: <code>p:first-child { font-weight: bold; }</code></li>
            <li><code>:focus</code>: элемент в фокусе (например, текстовое поле). <br>Пример: <code>input:focus { border-color: blue; }</code></li>
        </ul>
        <p>
            <strong>Псевдоэлементы (Pseudo-elements)</strong> обозначаются двойным двоеточием (<code>::</code>) и позволяют стилизовать **определенную часть элемента** или **добавлять декоративный контент** к элементу.
        </p>
        <p>
            <strong>Пример псевдоэлементов:</strong>
        </p>
        <ul>
            <li><code>::before</code> и <code>::after</code>: используются для вставки декоративного контента до или после содержимого элемента. <br>Пример: <code>h2::before { content: "➡️ "; }</code></li>
            <li><code>::first-line</code>: первая строка текста в элементе. <br>Пример: <code>p::first-line { text-transform: uppercase; }</code></li>
            <li><code>::selection</code>: выделенный пользователем текст. <br>Пример: <code>::selection { background-color: yellow; }</code></li>
        </ul>

        <h2>4. Как с помощью атрибутного селектора применить стили к элементам с определенным значением атрибута? Приведите пример.</h2>
        <p>
            <strong>Атрибутные селекторы</strong> позволяют выбирать элементы, основываясь на наличии или значении их HTML-атрибутов. Они записываются в квадратных скобках <code>[]</code>.
        </p>
        <p>
            Для применения стилей к элементам с **определенным значением атрибута** используется синтаксис <code>[атрибут="значение"]</code>.
        </p>
        <p>
            <strong>Пример:</strong> Стилизовать все поля ввода с типом "email" в зеленый цвет.
        </p>
        <p>
            HTML: <code>&lt;input type="email" placeholder="Ваш email"&gt;</code>
        </p>
        <p>
            CSS: <code>input[type="email"] { border-color: green; background-color: #e8f8f5; }</code>
        </p>
        <p>
            Кроме точного совпадения, существуют и другие операторы, например:
        </p>
        <ul>
            <li><code>[атрибут^="значение"]</code>: начинается с.</li>
            <li><code>[атрибут*="значение"]</code>: содержит подстроку.</li>
            <li><code>[атрибут$="значение"]</code>: заканчивается на.</li>
        </ul>

        <h2>5. В чем заключается разница между селектором потомков и селектором соседей? Как они применяются на практике?</h2>
        <p>
            Оба эти селектора являются **комбинаторами**, но имеют совершенно разные принципы работы.
        </p>
        
        <h3>Селектор потомков (Descendant Combinator)</h3>
        <p>
            Использует **пробел** между селекторами (`селектор1 селектор2`). Он выбирает **все** элементы, соответствующие `селектору2`, которые являются потомками (находятся внутри) элемента, соответствующего `селектору1`, на **любом уровне вложенности**.
        </p>
        <p>
            <strong>Практика:</strong> Ограничение стилей. Например, стилизовать только ссылки внутри боковой панели, не затрагивая остальные:
            <br><code>#sidebar a { color: #3498db; }</code>
        </p>

        <h3>Селектор соседей (Adjacent Sibling Combinator)</h3>
        <p>
            Использует знак **плюс** (`+`) между селекторами (`селектор1 + селектор2`). Он выбирает только **первый** элемент, соответствующий `селектору2`, который **непосредственно следует** за элементом, соответствующим `селектору1`, и имеет того же родителя.
        </p>
        <p>
            <strong>Практика:</strong> Установка интервалов между блоками. Например, добавить верхний отступ только для абзацев, которые идут сразу за заголовком:
            <br><code>h2 + p { margin-top: 1.5em; }</code>
        </p>
        
    </div>

</body>
</html>